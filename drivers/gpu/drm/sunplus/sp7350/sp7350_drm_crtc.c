// SPDX-License-Identifier: GPL-2.0+
/*
 * Sunplus SP7350 SoC DRM CRTCs
 *
 * Author: dx.jiang<dx.jiang@sunmedia.com.cn>
 *         hammer.hsieh<hammer.hsieh@sunplus.com>
 */

#include <linux/component.h>
#include <linux/of_device.h>
#include <linux/clk.h>
#include <linux/reset.h>
#include <linux/delay.h>

#include <drm/drm_atomic.h>
#include <drm/drm_atomic_helper.h>
#include <drm/drm_atomic_uapi.h>
//#include <drm/drm_fb_cma_helper.h>
#include <drm/drm_framebuffer.h>
#include <drm/drm_print.h>
#include <drm/drm_probe_helper.h>
#include <drm/drm_vblank.h>

#include "sp7350_drm_drv.h"
#include "sp7350_drm_crtc.h"
#include "sp7350_drm_plane.h"
#include "sp7350_drm_regs.h"

#define SP7350_TCON_TPG_EN  0

/**
 * @SP7350_PLANE_ZPOS_AUTO_ADJUST_EN:
 * Enable zpos auto ajdust for sp7350 display dmix setting.
 *
 * User-space may set mutable zpos properties so that multiple active
 * planes on the same CRTC have identical zpos values. This is a
 * user-space bug, but drivers can solve the conflict by comparing the
 * plane object IDs; the plane with a higher ID is stacked on top of a
 * plane with a lower ID.
 */
#define SP7350_PLANE_ZPOS_AUTO_ADJUST_EN  1

/*
 * DRM CRTC Setting
 */
#define SP7350_DRM_CRTC_CAP_BG_FORMAT   (1 << 0)
#define SP7350_DRM_CRTC_CAP_BG_COLOR    (1 << 1)
#define SP7350_DRM_CRTC_CAP_GAMMA_LUT   (1 << 2)

#define SP7350_CRTC_READ(offset) readl(sp_crtc->regs + (offset))
#define SP7350_CRTC_WRITE(offset, val) writel(val, sp_crtc->regs + (offset))

/*
 * Global properties
 */
static const struct drm_prop_enum_list drm_crtc_bg_format_enum_list[] = {
	//{ 0, (const char *)DRM_FORMAT_RGB888 },
	//{ 1, (const char *)DRM_FORMAT_YUV444 },
	{ 0, "RGB888" },
	{ 1, "YUV444" },
};

/* display TGEN Timing Parameters Setting.
 * Formula:
 *   total_pixel = htotal
 *   line_start_cd_point = hdisplay
 *   total_line = vtotal
 *   field_end_line = vdisplay+vtotal-vsync_start+1
 *   active_start_line = vtotal-vsync_start
 *
 * Notes: htotal,hdisplay,vtotal,vdisplay,vsync_start are derived from drm_display_mode.
 */
struct sp7350_crtc_tgen_timing_param {
	u32 total_pixel;
	u32 line_start_cd_point;
	u32 total_line;
	u32 field_end_line;
	u32 active_start_line;
};

/* display TCON Timing Parameters Setting.
 * HW Specification definition:
 *   TCON_HSA=4
 *   TCON_HBP=4
 *   TCON_VSA=1
 * Formula:
 *   de_hstart    = 0 (Horizontal reference starting point)
 *   de_hend      = de_hstart+hdisplay-1 = hdisplay-1
 *   hsync_start  = htotal-TCON_HSA-TCON_HBP = htotal-4-4
 *   hsync_end    = hsync_start + TCON_HSA = htotal-4
 *   de_oev_start = hsync_start
 *   de_oev_end   = hsync_end
 *   stvu_start   = vtotal-TCON_VSA = vtotal-1
 *   stvu_end     = 0 (Vertical reference starting point)
 *
 * Notes: hdisplay,htotal,vtotal are derived from drm_display_mode.
 */
struct sp7350_drm_tcon_timing_param {
	u32 de_hstart;
	u32 de_hend;
	u32 de_oev_start;
	u32 de_oev_end;
	u32 hsync_start;
	u32 hsync_end;
	u32 stvu_start;
	u32 stvu_end;
};

struct sp7350_crtc_state {
	struct drm_crtc_state base;
	bool gamma_lut_adjustment_enable;
	unsigned int background_format;
	unsigned int background_color;
	bool background_changed;
};

struct sp7350_crtc {
	struct drm_crtc base;
	struct drm_device *drm_dev;
	struct platform_device *pdev;
	void __iomem *regs;
	bool is_enabled;
	unsigned int background_color;
	bool gamma_lut_enabled;

	uint32_t capabilities;  /* SP7350_DRM_CRTC_CAP_XXX */
	struct drm_property *background_format_property;
	struct drm_property *background_color_property;
	struct drm_property *gamma_lut_adjustment_property;

	struct sp7350_crtc_tgen_timing_param tgen_timing;
	struct sp7350_drm_tcon_timing_param tcon_timing;
	struct drm_plane *planes[SP7350_MAX_PLANE];
	//struct drm_plane *primary_plane;
	//struct drm_plane *media_plane;
	//struct drm_plane *overlay_planes[2];
	//struct drm_plane *cursor_plane;

	/* protected by dev->event_lock */
	//struct drm_pending_vblank_event *event;

	int irq;
	bool irq_hw_enabled;  /* no hw irq en reg??? */
	/* lock irq set */
	spinlock_t irq_lock;
	/* protects crtc enable/disable */
	struct mutex lock;

	enum sp7350_encoder_type encoder_types[2];

	/* TODO: setting with C3V dipslay tcon feature. */
	u8 lut_r[256];
	u8 lut_g[256];
	u8 lut_b[256];

	struct debugfs_regset32 regset_g185;
	struct debugfs_regset32 regset_g186;
	struct debugfs_regset32 regset_g187;
	struct debugfs_regset32 regset_g188;

	struct debugfs_regset32 regset_g189;
	struct debugfs_regset32 regset_g190;
	struct debugfs_regset32 regset_g191;
	struct debugfs_regset32 regset_g192;
	struct debugfs_regset32 regset_g193;
	struct debugfs_regset32 regset_g194;
	struct debugfs_regset32 regset_g195;
	struct debugfs_regset32 regset_g196;

	struct debugfs_regset32 regset_g197;
	struct debugfs_regset32 regset_g198;

	struct debugfs_regset32 regset_g199;
	struct debugfs_regset32 regset_g200;
	struct debugfs_regset32 regset_g201;
	struct debugfs_regset32 regset_g202;
	struct debugfs_regset32 regset_g203;
};

#define to_sp7350_crtc(crtc) \
	container_of(crtc, struct sp7350_crtc, base)

#define to_sp7350_crtc_state(state) \
		container_of(state, struct sp7350_crtc_state, base)

/*
 * SP7350 DISPLAY IMGREAD: Video Imgage Read
 */
static const struct debugfs_reg32 crtc_regs_g185[] = {
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_00),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_01),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_02),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_03),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_04),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_05),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_06),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_07),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_08),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_09),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_10),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_11),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_12),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_13),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_14),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_15),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_16),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_17),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_18),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_19),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_20),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_21),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_22),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_23),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_24),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_25),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_26),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_27),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_28),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_29),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_30),
	SP7350_DRM_REG32(SP7350_DISP_IMGREAD_G185_31),
};

/*
 * SP7350 DISPLAY VSCL0_G0: Video Scaler Group 0
 */
static const struct debugfs_reg32 crtc_regs_g186[] = {
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_00),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_01),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_02),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_03),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_04),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_05),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_06),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_07),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_08),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_09),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_10),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_11),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_12),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_13),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_14),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_15),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_16),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_17),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_18),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_19),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_20),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_21),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_22),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_23),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_24),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_25),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_26),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_27),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_28),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_29),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_30),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G0_G186_31),
};

/*
 * SP7350 DISPLAY VSCL0_G1: Video Scaler Group 1
 */
static const struct debugfs_reg32 crtc_regs_g187[] = {
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_00),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_01),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_02),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_03),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_04),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_05),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_06),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_07),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_08),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_09),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_10),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_11),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_12),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_13),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_14),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_15),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_16),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_17),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_18),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_19),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_20),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_21),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_22),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_23),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_24),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_25),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_26),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_27),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_28),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_29),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_30),
	SP7350_DRM_REG32(SP7350_DISP_VSCL0_G1_G187_31),
};

/*
 * SP7350 DISPLAY VPOST0: Video Post Processor
 */
static const struct debugfs_reg32 crtc_regs_g188[] = {
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_00),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_01),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_02),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_03),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_04),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_05),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_06),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_07),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_08),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_09),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_10),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_11),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_12),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_13),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_14),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_15),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_16),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_17),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_18),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_19),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_20),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_21),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_22),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_23),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_24),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_25),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_26),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_27),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_28),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_29),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_30),
	SP7350_DRM_REG32(SP7350_DISP_VPOST0_G188_31),
};

/*
 * SP7350 DISPLAY OSD0: On Screen Dsiplay Layer0
 */
static const struct debugfs_reg32 crtc_regs_g189[] = {
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_00),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_01),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_02),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_03),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_04),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_05),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_06),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_07),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_08),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_09),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_10),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_11),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_12),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_13),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_14),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_15),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_16),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_17),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_18),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_19),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_20),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_21),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_22),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_23),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_24),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_25),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_26),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_27),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_28),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_29),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_30),
	SP7350_DRM_REG32(SP7350_DISP_OSD0_G189_31),
};

/*
 * SP7350 DISPLAY OSD1: On Screen Dsiplay Layer1
 */
static const struct debugfs_reg32 crtc_regs_g190[] = {
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_00),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_01),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_02),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_03),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_04),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_05),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_06),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_07),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_08),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_09),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_10),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_11),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_12),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_13),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_14),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_15),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_16),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_17),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_18),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_19),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_20),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_21),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_22),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_23),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_24),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_25),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_26),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_27),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_28),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_29),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_30),
	SP7350_DRM_REG32(SP7350_DISP_OSD1_G190_31),
};

/*
 * SP7350 DISPLAY OSD2: On Screen Dsiplay Layer2
 */
static const struct debugfs_reg32 crtc_regs_g191[] = {
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_00),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_01),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_02),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_03),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_04),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_05),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_06),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_07),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_08),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_09),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_10),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_11),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_12),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_13),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_14),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_15),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_16),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_17),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_18),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_19),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_20),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_21),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_22),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_23),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_24),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_25),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_26),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_27),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_28),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_29),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_30),
	SP7350_DRM_REG32(SP7350_DISP_OSD2_G191_31),
};

/*
 * SP7350 DISPLAY OSD3: On Screen Dsiplay Layer3
 */
static const struct debugfs_reg32 crtc_regs_g192[] = {
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_00),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_01),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_02),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_03),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_04),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_05),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_06),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_07),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_08),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_09),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_10),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_11),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_12),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_13),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_14),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_15),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_16),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_17),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_18),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_19),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_20),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_21),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_22),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_23),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_24),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_25),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_26),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_27),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_28),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_29),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_30),
	SP7350_DRM_REG32(SP7350_DISP_OSD3_G192_31),
};

/*
 * SP7350 DISPLAY GPOST0: Graphic Post Processor for OSD0
 */
static const struct debugfs_reg32 crtc_regs_g193[] = {
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_00),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_01),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_02),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_03),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_04),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_05),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_06),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_07),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_08),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_09),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_10),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_11),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_12),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_13),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_14),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_15),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_16),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_17),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_18),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_19),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_20),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_21),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_22),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_23),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_24),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_25),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_26),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_27),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_28),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_29),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_30),
	SP7350_DRM_REG32(SP7350_DISP_GPOST0_G193_31),
};

/*
 * SP7350 DISPLAY GPOST1: Graphic Post Processor for OSD1
 */
static const struct debugfs_reg32 crtc_regs_g194[] = {
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_00),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_01),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_02),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_03),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_04),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_05),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_06),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_07),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_08),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_09),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_10),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_11),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_12),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_13),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_14),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_15),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_16),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_17),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_18),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_19),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_20),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_21),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_22),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_23),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_24),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_25),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_26),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_27),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_28),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_29),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_30),
	SP7350_DRM_REG32(SP7350_DISP_GPOST1_G194_31),
};

/*
 * SP7350 DISPLAY GPOST2: Graphic Post Processor for OSD2
 */
static const struct debugfs_reg32 crtc_regs_g195[] = {
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_00),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_01),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_02),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_03),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_04),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_05),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_06),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_07),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_08),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_09),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_10),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_11),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_12),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_13),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_14),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_15),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_16),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_17),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_18),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_19),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_20),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_21),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_22),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_23),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_24),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_25),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_26),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_27),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_28),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_29),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_30),
	SP7350_DRM_REG32(SP7350_DISP_GPOST2_G195_31),
};

/*
 * SP7350 DISPLAY GPOST3: Graphic Post Processor for OSD3
 */
static const struct debugfs_reg32 crtc_regs_g196[] = {
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_00),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_01),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_02),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_03),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_04),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_05),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_06),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_07),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_08),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_09),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_10),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_11),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_12),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_13),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_14),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_15),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_16),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_17),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_18),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_19),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_20),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_21),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_22),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_23),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_24),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_25),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_26),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_27),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_28),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_29),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_30),
	SP7350_DRM_REG32(SP7350_DISP_GPOST3_G196_31),
};

/*
 * SP7350 DISPLAY TGEN: Timing Generator
 */
static const struct debugfs_reg32 crtc_regs_g197[] = {
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_00),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_01),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_02),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_03),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_04),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_05),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_06),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_07),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_08),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_09),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_10),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_11),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_12),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_13),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_14),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_15),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_16),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_17),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_18),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_19),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_20),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_21),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_22),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_23),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_24),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_25),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_26),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_27),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_28),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_29),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_30),
	SP7350_DRM_REG32(SP7350_DISP_TGEN_G197_31),
};

/*
 * SP7350 DISPLAY DMIX0: Display Mixer
 */
static const struct debugfs_reg32 crtc_regs_g198[] = {
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_00),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_01),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_02),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_03),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_04),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_05),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_06),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_07),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_08),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_09),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_10),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_11),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_12),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_13),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_14),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_15),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_16),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_17),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_18),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_19),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_20),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_21),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_22),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_23),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_24),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_25),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_26),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_27),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_28),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_29),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_30),
	SP7350_DRM_REG32(SP7350_DISP_DMIX0_G198_31),
};

/*
 * SP7350 DISPLAY TCON: Timing Control PART1
 */
static const struct debugfs_reg32 crtc_regs_g199[] = {
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_00),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_01),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_02),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_03),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_04),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_05),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_06),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_07),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_08),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_09),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_10),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_11),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_12),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_13),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_14),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_15),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_16),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_17),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_18),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_19),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_20),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_21),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_22),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_23),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_24),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_25),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_26),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_27),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_28),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_29),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_30),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G199_31),
};

/*
 * SP7350 DISPLAY TCON: Timing Control PART2
 */
static const struct debugfs_reg32 crtc_regs_g200[] = {
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_00),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_01),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_02),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_03),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_04),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_05),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_06),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_07),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_08),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_09),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_10),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_11),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_12),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_13),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_14),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_15),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_16),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_17),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_18),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_19),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_20),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_21),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_22),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_23),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_24),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_25),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_26),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_27),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_28),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_29),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_30),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G200_31),
};

/*
 * SP7350 DISPLAY TCON: Timing Control PART3
 */
static const struct debugfs_reg32 crtc_regs_g201[] = {
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_00),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_01),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_02),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_03),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_04),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_05),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_06),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_07),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_08),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_09),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_10),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_11),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_12),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_13),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_14),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_15),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_16),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_17),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_18),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_19),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_20),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_21),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_22),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_23),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_24),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_25),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_26),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_27),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_28),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_29),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_30),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G201_31),
};

/*
 * SP7350 DISPLAY TCON: Timing Control (RESERVED)
 */
static const struct debugfs_reg32 crtc_regs_g202[] = {
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_00), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_01), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_02), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_03), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_04), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_05), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_06), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_07), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_08), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_09), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_10), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_11), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_12), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_13), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_14), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_15), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_16), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_17), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_18), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_19), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_20), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_21), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_22), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_23), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_24), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_25), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_26), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_27), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_28), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_29), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_30), /* reserved */
	SP7350_DRM_REG32(SP7350_DISP_TCON_G202_31), /* reserved */
};

/*
 * SP7350 DISPLAY TCON: Timing Control PART4
 */
static const struct debugfs_reg32 crtc_regs_g203[] = {
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_00),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_01),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_02),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_03),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_04),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_05),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_06),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_07),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_08),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_09),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_10),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_11),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_12),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_13),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_14),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_15),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_16),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_17),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_18),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_19),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_20),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_21),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_22),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_23),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_24),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_25),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_26),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_27),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_28),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_29),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_30),
	SP7350_DRM_REG32(SP7350_DISP_TCON_G203_31),
};

#if SP7350_TCON_TPG_EN
/*
 * sp_tcon_tpg_para_dsi[x][y]
 * y = 0-1, TCON width & height
 * y = 2-9, TCON Hstep & Vstep & Hcnt & Vcnt & Hact & Vact & A_LINE & DITHER
 */
static const u32 sp_tcon_tpg_para_dsi[11][10] = {
	/* (w   h)    Hstep Vstep Hcnt  Vcnt  Hact  Vact A_LINE DITHER */
	{ 720,  480,    4,    4,  857,  524,  719,  479,  35, 0x01}, /* 480P */
	{ 720,  576,    4,    4,  863,  624,  719,  575,  17, 0x41}, /* 576P */
	{1280,  720,    4,    4, 1649,  749, 1279,  719,  24, 0x41}, /* 720P */
	{1920, 1080,    4,    4, 2199, 1124, 1919, 1079,  40, 0x01}, /* 1080P */
	//{  64,   64,    4,    4,  359,   99,   63,   63,  17, 0xC1}, /* 64x64 */
	{ 480, 1280,    4,    4,  619, 1313,  479, 1279,  16, 0x01}, /* 480x1280 */
	{ 128,  128,    4,    4,  359,  149,  127,  127,  17, 0x49}, /* 128x128 */
	{ 240,  320,    4,    4,  682,  353,  239,  319,  25, 0x01}, /* 240x320 */
	{3840,   64,    4,    4, 4607,   99, 3839,   63,  17, 0x01}, /* 3840x64 */
	{3840, 2880,    4,    4, 4607, 3199, 3839, 2879,  17, 0x01}, /* 3840x2880 */
	{ 800,  480,    4,    4,  872,  509,  799,  479,  22, 0x01}, /* 800x480 */
	{1024,  600,    4,    4, 1343,  634, 1023,  599,  17, 0x01}  /* 1024x600 */
};
#endif
static void sp7350_crtc_dmix_layer_setting(struct drm_crtc *crtc);

#if SP7350_PLANE_ZPOS_AUTO_ADJUST_EN
static int sp7350_rearrange_zpos(unsigned int in[], unsigned int out[], int size)
{
	for (int i = size - 1; i >= 0; i--) {
		unsigned int larger = 0;
		unsigned int smaller = 0;

		/* Check forward if the largest */
		for (int j = 0; j < i; j++)
			if (in[j] > in[i])
				larger++;

		/* Check backwards if smallest */
		for (int j = i + 1; j < size; j++)
			if (in[j] < in[i])
				smaller++;

		out[i] = i - larger + smaller;
		//DRM_DEBUG_DRIVER("in[%d]:%d, larger:%d, out[%d]:%d\n", i, in[i], larger, i, out[i]);
	}

	return 0;
}
#endif

static irqreturn_t sp7350_crtc_irq_handler(int irq, void *data)
{
	struct sp7350_crtc *sp_crtc = data;
	irqreturn_t ret = IRQ_NONE;

	//DRM_DEBUG_DRIVER("irq:%d\n", irq);

	/* [FIXME]always return IRQ_HANDLED, fix IRQ disable by system. */
	ret = IRQ_HANDLED;

	/* todo:no hw irq en reg??? */
	spin_lock(&sp_crtc->irq_lock);
	if (!sp_crtc->irq_hw_enabled) {
		//DRM_DEBUG_DRIVER("irq hw disabled.\n");
		spin_unlock(&sp_crtc->irq_lock);
		return ret;
	}
	spin_unlock(&sp_crtc->irq_lock);

	if (!sp_crtc->drm_dev || !sp_crtc->drm_dev->num_crtcs) {
		//DRM_DEBUG_DRIVER("not bind any crtc yet.\n");
		return ret;
	}

	drm_crtc_handle_vblank(&sp_crtc->base);
	//ret = IRQ_HANDLED;

	return ret;
}

/*
 * drm_crtc_helper_funcs
 */
static void sp7350_crtc_dmix_init(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	u32 value;


	/* DMIX Setting for DRM Driver:
	 * L6   L5   L4   L3   L2   L1   BG
	 * OSD0 OSD1 OSD2 VPP0 ---- OSD3 PTG
	 */
	//value = 0;
	//value |= SP7350_DMIX_L6_FG_SEL(SP7350_DMIX_OSD0_SEL) |
	//	SP7350_DMIX_L5_FG_SEL(SP7350_DMIX_OSD1_SEL) |
	//	SP7350_DMIX_L4_FG_SEL(SP7350_DMIX_OSD2_SEL) |
	//	SP7350_DMIX_L3_FG_SEL(SP7350_DMIX_VPP0_SEL) |
	//	SP7350_DMIX_L2_FG_SEL(SP7350_DMIX_VPP1_SEL) |
	//	SP7350_DMIX_L1_FG_SEL(SP7350_DMIX_OSD3_SEL) |
	//	SP7350_DMIX_BG_FG_SEL(SP7350_DMIX_PTG_SEL);
	//SP7350_CRTC_WRITE(DMIX_LAYER_CONFIG_0, value); //(drm setting)
	if (crtc && crtc->dev)
		sp7350_crtc_dmix_layer_setting(crtc);

	/* DMIX setting MODE_SEL
	 * L6   L5   L4   L3   L2   L1   BG
	 * OSD0 OSD1 OSD2 VPP0 ---- OSD3 PTG
	 * (AlphaBlend / Transparent / Opacity setting)
	 */
	value = 0;
	value |= SP7350_DMIX_L6_MODE_SEL(SP7350_DMIX_TRANSPARENT) |
		SP7350_DMIX_L5_MODE_SEL(SP7350_DMIX_TRANSPARENT) |
		SP7350_DMIX_L4_MODE_SEL(SP7350_DMIX_TRANSPARENT) |
		SP7350_DMIX_L3_MODE_SEL(SP7350_DMIX_TRANSPARENT) |
		SP7350_DMIX_L2_MODE_SEL(SP7350_DMIX_TRANSPARENT) |
		SP7350_DMIX_L1_MODE_SEL(SP7350_DMIX_TRANSPARENT);
	SP7350_CRTC_WRITE(DMIX_LAYER_CONFIG_1, value); //All AlphaBlend

	/* DMIX PTG(default border pixel len=0 (BGC))
	 */
	value = 0;
	value |= SP7350_DMIX_PTG_BORDER_PATTERN(SP7350_DMIX_PTG_BORDER) |
		SP7350_DMIX_PTG_BORDER_PIX(SP7350_DMIX_PTG_BORDER_PIX_00);
	SP7350_CRTC_WRITE(DMIX_PTG_CONFIG_0, value); //BackGround + Border pix = 0

	/* DMIX PTG(BackGround Color Setting)
	 */
	value = 0;
	value |= sp_crtc->background_color;
	SP7350_CRTC_WRITE(DMIX_PTG_CONFIG_2, value);

	/* DMIX PIXEL_EN_SEL
	 */
	value = 0;
	value |= SP7350_DMIX_SOURCE_SEL(SP7350_DMIX_TCON0_DMIX);
	SP7350_CRTC_WRITE(DMIX_SOURCE_SEL, value); //PIXEL_EN_SEL=TCON0(don't change)
}

static void sp7350_crtc_tgen_init(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);


	SP7350_CRTC_WRITE(TGEN_CONFIG, 0x00000000);
	SP7350_CRTC_WRITE(TGEN_USER_INT1_CONFIG, 0x0000000a);
	SP7350_CRTC_WRITE(TGEN_USER_INT2_CONFIG, 0x0000000a);

	/* Write 1 to reset DTG timing bit
	 */
	SP7350_CRTC_WRITE(TGEN_RESET, 0x00000001);
}

static void sp7350_crtc_tcon_init(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);


	SP7350_CRTC_WRITE(TCON_TCON0, 0x00008127);
	SP7350_CRTC_WRITE(TCON_TCON1, 0x00008011);
	SP7350_CRTC_WRITE(TCON_TCON2, 0x00000011); //don't care
	SP7350_CRTC_WRITE(TCON_TCON3, 0x00002002); //don't care
	SP7350_CRTC_WRITE(TCON_TCON4, 0x00000000); //fixed , don't change it
	SP7350_CRTC_WRITE(TCON_TCON5, 0x00000004); //don't care
}

static void sp7350_crtc_dmix_layer_setting(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct drm_plane *plane = NULL;
	u32 dtg_adj1_value, dtg_adj2_value, dtg_adj3_value, dtg_adj4_value;
	u32 value;

	/* DMIX Layer and DTG Adjust Setting.
	 */
	value = SP7350_CRTC_READ(DMIX_LAYER_CONFIG_0);
	dtg_adj1_value = SP7350_CRTC_READ(TGEN_DTG_ADJUST1);
	dtg_adj2_value = SP7350_CRTC_READ(TGEN_DTG_ADJUST2);
	dtg_adj3_value = SP7350_CRTC_READ(TGEN_DTG_ADJUST3);
	dtg_adj4_value = SP7350_CRTC_READ(TGEN_DTG_ADJUST4);

	drm_for_each_plane(plane, crtc->dev) {
		struct sp7350_plane *sp_plane = to_sp7350_plane(plane);

		if (plane->possible_crtcs != drm_crtc_mask(crtc))
			continue;

		switch (sp_plane->dmix_layer) {
		case SP7350_DMIX_L1:
			value &= ~SP7350_DMIX_L1_FG_SEL;
			value |= SP7350_DMIX_L1_FG_SEL_SET(sp_plane->dmix_fg_sel);
			break;
		case SP7350_DMIX_L3:
			value &= ~SP7350_DMIX_L3_FG_SEL;
			value |= SP7350_DMIX_L3_FG_SEL_SET(sp_plane->dmix_fg_sel);
			break;
		case SP7350_DMIX_L4:
			value &= ~SP7350_DMIX_L4_FG_SEL;
			value |= SP7350_DMIX_L4_FG_SEL_SET(sp_plane->dmix_fg_sel);
			break;
		case SP7350_DMIX_L5:
			value &= ~SP7350_DMIX_L5_FG_SEL;
			value |= SP7350_DMIX_L5_FG_SEL_SET(sp_plane->dmix_fg_sel);
			break;
		case SP7350_DMIX_L6:
			value &= ~SP7350_DMIX_L6_FG_SEL;
			value |= SP7350_DMIX_L6_FG_SEL_SET(sp_plane->dmix_fg_sel);
			break;
		}

		switch (sp_plane->dmix_fg_sel) {
		case SP7350_DMIX_VPP0_SEL:
			dtg_adj1_value &= ~SP7350_TGEN_DTG_ADJ_MASKA;
			dtg_adj1_value |= SP7350_TGEN_DTG_ADJ_MASKA_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_VPP1_SEL:
			dtg_adj1_value &= ~SP7350_TGEN_DTG_ADJ_MASKB;
			dtg_adj1_value |= SP7350_TGEN_DTG_ADJ_MASKB_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_OSD3_SEL:
			dtg_adj2_value &= ~SP7350_TGEN_DTG_ADJ_MASKA;
			dtg_adj2_value |= SP7350_TGEN_DTG_ADJ_MASKA_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_OSD2_SEL:
			dtg_adj2_value &= ~SP7350_TGEN_DTG_ADJ_MASKB;
			dtg_adj2_value |= SP7350_TGEN_DTG_ADJ_MASKB_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_OSD1_SEL:
			dtg_adj3_value &= ~SP7350_TGEN_DTG_ADJ_MASKA;
			dtg_adj3_value |= SP7350_TGEN_DTG_ADJ_MASKA_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_OSD0_SEL:
			dtg_adj3_value &= ~SP7350_TGEN_DTG_ADJ_MASKB;
			dtg_adj3_value |= SP7350_TGEN_DTG_ADJ_MASKB_SET(sp_plane->dtg_adjust);
			break;
		case SP7350_DMIX_PTG_SEL:
			dtg_adj4_value &= ~SP7350_TGEN_DTG_ADJ_MASKA;
			dtg_adj4_value |= SP7350_TGEN_DTG_ADJ_MASKA_SET(sp_plane->dtg_adjust);
			break;
		}
	}

	SP7350_CRTC_WRITE(DMIX_LAYER_CONFIG_0, value);
	SP7350_CRTC_WRITE(TGEN_DTG_ADJUST1, dtg_adj1_value);
	SP7350_CRTC_WRITE(TGEN_DTG_ADJUST2, dtg_adj2_value);
	SP7350_CRTC_WRITE(TGEN_DTG_ADJUST3, dtg_adj3_value);
	SP7350_CRTC_WRITE(TGEN_DTG_ADJUST4, dtg_adj4_value);
}

static void sp7350_crtc_tgen_timing_setting(struct drm_crtc *crtc, struct drm_display_mode *mode)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct sp7350_crtc_tgen_timing_param *tgen_timing = &sp_crtc->tgen_timing;
	u32 value;

	if (mode) {
		/* Generate tgen timing setting from drm_display_mode */
		tgen_timing->total_pixel = mode->htotal;
		tgen_timing->total_line  = mode->vtotal;
		tgen_timing->line_start_cd_point = mode->hdisplay;
		tgen_timing->active_start_line   = mode->vtotal - mode->vsync_start;
		tgen_timing->field_end_line      = tgen_timing->active_start_line + mode->vdisplay + 1;
	}
	if (!tgen_timing->total_pixel || !tgen_timing->total_line) {
		/* do nothing */
		return;
	}

	DRM_DEBUG_DRIVER("\nTGEN Timing Setting:\n"
		 "   TGEN_DTG_TOTAL_PIXEL=%d, TGEN_DTG_DS_LINE_START_CD_POINT=%d\n"
		 "   TGEN_DTG_TOTAL_LINE=%d, TGEN_DTG_FIELD_END_LINE=%d, TGEN_DTG_START_LINE=%d\n",
		 tgen_timing->total_pixel, tgen_timing->line_start_cd_point,
		 tgen_timing->total_line, tgen_timing->field_end_line, tgen_timing->active_start_line);

	/* TGEN timing init
	 */
	/* Fixed user mode. */
	value = SP7350_CRTC_READ(TGEN_DTG_CONFIG);
	value &= ~(SP7350_TGEN_FORMAT | SP7350_TGEN_FPS | SP7350_TGEN_USER_MODE);
	value |= SP7350_TGEN_USER_MODE;
	SP7350_CRTC_WRITE(TGEN_DTG_CONFIG, value);

	SP7350_CRTC_WRITE(TGEN_DTG_TOTAL_PIXEL, tgen_timing->total_pixel);
	SP7350_CRTC_WRITE(TGEN_DTG_DS_LINE_START_CD_POINT, tgen_timing->line_start_cd_point);
	SP7350_CRTC_WRITE(TGEN_DTG_TOTAL_LINE, tgen_timing->total_line);
	SP7350_CRTC_WRITE(TGEN_DTG_FIELD_END_LINE, tgen_timing->field_end_line);
	SP7350_CRTC_WRITE(TGEN_DTG_START_LINE, tgen_timing->active_start_line);

	//SP7350_CRTC_WRITE(TGEN_DTG_ADJUST1, 0x0000100d);
	SP7350_CRTC_WRITE(TGEN_SOURCE_SEL, 0x00000000);

	/* Write 1 to reset DTG timing bit
	 */
	SP7350_CRTC_WRITE(TGEN_RESET, 0x00000001);
}

static void sp7350_crtc_tcon_timing_setting(struct drm_crtc *crtc, struct drm_display_mode *mode)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	struct sp7350_drm_tcon_timing_param *tcon_timing = &sp_crtc->tcon_timing;

	if (mode) {
		/* fixed parameters for mipitx timing */
		u16 tcon_hsa = 4;
		u16 tcon_hbp = 4;
		u16 tcon_vsa = 1;

		if (!mode->hdisplay || !mode->vtotal) {
			/* do nothing */
			return;
		}

		tcon_timing->de_hstart    = 0;
		tcon_timing->de_hend      = tcon_timing->de_hstart + mode->hdisplay - 1;
		tcon_timing->hsync_start  = mode->htotal - tcon_hsa - tcon_hbp;
		tcon_timing->hsync_end    = tcon_timing->hsync_start + tcon_hsa;
		tcon_timing->de_oev_start = tcon_timing->hsync_start;
		tcon_timing->de_oev_end   = tcon_timing->hsync_end;
		tcon_timing->stvu_start   = mode->vtotal - tcon_vsa;
		tcon_timing->stvu_end     = 0;
	}
	if (!tcon_timing->de_hend) {
		/* do nothing */
		return;
	}

	DRM_DEBUG_DRIVER("\nTCON Timing Setting:\n"
		"   TCON_DE_HSTART=%u, TCON_DE_HEND=%u, TCON_OEV_START=%u, TCON_OEV_END=%u\n"
		"   TCON_HSYNC_START=%u, TCON_HSYNC_END=%u, TCON_STVU_START=%u, TCON_STVU_END=%u\n",
		tcon_timing->de_hstart, tcon_timing->de_hend, tcon_timing->de_oev_start, tcon_timing->de_oev_end,
		tcon_timing->hsync_start, tcon_timing->hsync_end, tcon_timing->stvu_start, tcon_timing->stvu_end);

	/*
	 * TCON H&V timing parameter
	 */
	SP7350_CRTC_WRITE(TCON_DE_HSTART, tcon_timing->de_hstart); //DE_HSTART
	SP7350_CRTC_WRITE(TCON_DE_HEND, tcon_timing->de_hend); //DE_HEND

	SP7350_CRTC_WRITE(TCON_OEV_START, tcon_timing->de_oev_start); //TC_VSYNC_HSTART
	SP7350_CRTC_WRITE(TCON_OEV_END, tcon_timing->de_oev_end); //TC_VSYNC_HEND

	SP7350_CRTC_WRITE(TCON_HSYNC_START, tcon_timing->hsync_start); //HSYNC_START
	SP7350_CRTC_WRITE(TCON_HSYNC_END, tcon_timing->hsync_end); //HSYNC_END

	//SP7350_CRTC_WRITE(TCON_DE_VSTART, 0); //DE_VSTART
	//SP7350_CRTC_WRITE(TCON_DE_VEND, 0); //DE_VEND

	SP7350_CRTC_WRITE(TCON_STVU_START, tcon_timing->stvu_start); //VTOP_VSTART
	SP7350_CRTC_WRITE(TCON_STVU_END, tcon_timing->stvu_end); //VTOP_VEND
}

#if SP7350_TCON_TPG_EN
static void sp7350_crtc_tcon_tpg_setting(struct drm_crtc *crtc, struct drm_display_mode *mode)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	int i, time_cnt = 0;
	u32 value = 0;

	for (i = 0; i < 11; i++) {
		if ((sp_tcon_tpg_para_dsi[i][0] == mode->hdisplay) &&
			(sp_tcon_tpg_para_dsi[i][1] == mode->vdisplay)) {
			time_cnt = i;
			break;
		}
	}

	DRM_DEBUG_DRIVER("(w h)(%d %d)\n",
		sp_tcon_tpg_para_dsi[time_cnt][0], sp_tcon_tpg_para_dsi[time_cnt][1]);

	/*
	 * TPG(Test Pattern Gen) parameter
	 */
	SP7350_CRTC_WRITE(TCON_TPG_HCOUNT, sp_tcon_tpg_para_dsi[time_cnt][4]);
	value = 0;
	value |= (sp_tcon_tpg_para_dsi[time_cnt][2] << 12) | sp_tcon_tpg_para_dsi[time_cnt][5];
	SP7350_CRTC_WRITE(TCON_TPG_VCOUNT, value);
	SP7350_CRTC_WRITE(TCON_TPG_HACT_COUNT, sp_tcon_tpg_para_dsi[time_cnt][6]);
	value = 0;
	value |= (sp_tcon_tpg_para_dsi[time_cnt][3] << 12) | sp_tcon_tpg_para_dsi[time_cnt][7];
	SP7350_CRTC_WRITE(TCON_TPG_VACT_COUNT, value);
	SP7350_CRTC_WRITE(TCON_TPG_ALINE_START, sp_tcon_tpg_para_dsi[time_cnt][8]);
	//SP7350_CRTC_WRITE(TCON_DITHER_TVOUT, sp_tcon_tpg_para_dsi[time_cnt][9]);
}
#endif

static void sp7350_crtc_tcon_gamma_table_set(struct drm_crtc *crtc,
					     u32 updsel_rgb, const u16 *table, u32 tablesize)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	int i;
	u32 value = 0;

	/* Prepare */
	do {
		value = SP7350_CRTC_READ(TCON_GAMMA0); //G200.00
		if (!(value & SP7350_TCON_GM_UPDEN))
			break;

		udelay(100);
	} while (1);

	value &= ~(SP7350_TCON_GM_UPDDEL_RGB_MASK);
	value |= SP7350_TCON_GM_EN | SP7350_TCON_GM_UPD_SCHEME | SP7350_TCON_GM_BYPASS |
			SP7350_TCON_GM_UPDWE | SP7350_TCON_GM_UPDDEL_RGB_SET(updsel_rgb);
	SP7350_CRTC_WRITE(TCON_GAMMA0, value);

	/* Write data to SRAM. */
	for (i = 0; i < tablesize; i++) {
		SP7350_CRTC_WRITE(TCON_GAMMA1, i);
		SP7350_CRTC_WRITE(TCON_GAMMA2, table[i]);
		value |= SP7350_TCON_GM_UPDEN;
		SP7350_CRTC_WRITE(TCON_GAMMA0, value);
		do {
			value = SP7350_CRTC_READ(TCON_GAMMA0); //G200.00
			if (!(value & SP7350_TCON_GM_UPDEN))
				break;

			udelay(100);
		} while (1);
	}

	/* workaround for write, write last -> read first. */
	//#if C3V_DISP_TCON_GAMMA_WORKAROUND_EN
	value = 0x00000021;
	SP7350_CRTC_WRITE(TCON_GAMMA0, value);
	//#endif
}

//static void sp7350_crtc_tcon_gamma_table_get(struct drm_crtc *crtc,
//					       u32 updsel_rgb, u16 table[], u32 tablesize)
//{
//	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
//	int i;
//	u32 value = 0;
//
//	/* Prepare */
//	do {
//		value = SP7350_CRTC_READ(TCON_GAMMA0); //G200.00
//		if (!(value & SP7350_TCON_GM_UPDEN))
//			break;
//		udelay(100);
//	} while(1);
//
//	//value2 = value;
//	value &= ~(SP7350_TCON_GM_UPDDEL_RGB_MASK);
//	value |= SP7350_TCON_GM_EN | SP7350_TCON_GM_BYPASS |
//			SP7350_TCON_GM_UPDDEL_RGB_SET(updsel_rgb);
//
//	value &= ~(SP7350_TCON_GM_UPDWE);
//	SP7350_CRTC_WRITE(TCON_GAMMA0, value);
//
//	/* Read data from SRAM. */
//	for(i = 0; i < tablesize ; i++) {
//		SP7350_CRTC_WRITE(TCON_GAMMA1, i);
//		value |= SP7350_TCON_GM_UPDEN;
//		SP7350_CRTC_WRITE(TCON_GAMMA0, value);
//		do {
//			value = SP7350_CRTC_READ(TCON_GAMMA0); //G200.00
//			if (!(value & SP7350_TCON_GM_UPDEN)) {
//				table[i] = SP7350_CRTC_READ(TCON_GAMMA2); //G200.00
//				break;
//			}
//			udelay(100);
//		} while(1);
//	}
//}

static void sp7350_crtc_tcon_gamma_table_enable(struct drm_crtc *crtc, int enable)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	u32 value = 0;

	value = SP7350_CRTC_READ(TCON_GAMMA0); //G200.00
	if (enable) {
		/* Enable Gamma Correction */
		value |= SP7350_TCON_GM_EN;
		value &= ~(SP7350_TCON_GM_BYPASS | SP7350_TCON_GM_UPDWE);
	} else {
		value &= ~(SP7350_TCON_GM_EN);
		value |= SP7350_TCON_GM_BYPASS;
	}

	SP7350_CRTC_WRITE(TCON_GAMMA0, value);
}

static struct drm_crtc_state *
sp7350_crtc_atomic_duplicate_state(struct drm_crtc *crtc)
{
	struct sp7350_crtc_state *sp_state;

	if (WARN_ON(!crtc->state))
		return NULL;

	DRM_DEBUG_ATOMIC("crtc-%d atomic_duplicate_state.\n", crtc->index);
	sp_state = kmemdup(to_sp7350_crtc_state(crtc->state),
			sizeof(*sp_state), GFP_KERNEL);
	if (!sp_state)
		return NULL;

	__drm_atomic_helper_crtc_duplicate_state(crtc, &sp_state->base);

	WARN_ON(sp_state->base.crtc != crtc);

	return &sp_state->base;
}

static void sp7350_crtc_atomic_destroy_state(struct drm_crtc *crtc,
					  struct drm_crtc_state *state)
{
	struct sp7350_crtc_state *sp_state = to_sp7350_crtc_state(state);

	DRM_DEBUG_ATOMIC("crtc-%d atomic_destroy_state.\n", crtc->index);
	__drm_atomic_helper_crtc_destroy_state(state);
	kfree(sp_state);
}

static void sp7350_crtc_reset(struct drm_crtc *crtc)
{
	struct sp7350_crtc_state *sp_state;
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	if (crtc->state)
		crtc->funcs->atomic_destroy_state(crtc, crtc->state);

	DRM_DEBUG_DRIVER("reset crtc-%d state.\n", crtc->index);

	sp_state = kzalloc(sizeof(*sp_state), GFP_KERNEL);
	if (!sp_state)
		return;

	__drm_atomic_helper_crtc_reset(crtc, &sp_state->base);

	/* reset to default crtc property parameters */
	if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT)
		sp_state->gamma_lut_adjustment_enable = 1;
	if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT)
		sp_state->background_format = 1;
	if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR)
		sp_state->background_color = SP7350_DMIX_PTG_BLACK;
	sp_state->background_changed = true;
}

//static u16 tmptable2[512];
int sp7350_crtc_gamma_set(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
	 uint32_t size,
	 struct drm_modeset_acquire_ctx *ctx)
{
	//pr_info("Set crtc-%d gamma table size:%d\n", crtc->index, size);
	int enable = 0;

	if (size > 512) {
		DRM_DEBUG_DRIVER("the gamma table size[%d] isn't supported by the driver!\n", size);
		return -EINVAL;
	}

	if (r) {
		enable = 1;
		sp7350_crtc_tcon_gamma_table_set(crtc, SP7350_TCON_GM_UPDDEL_RGB_R, r, size);
		//sp7350_crtc_tcon_gamma_table_get(crtc, SP7350_TCON_GM_UPDDEL_RGB_R, tmptable2, size);
		//if (memcmp(r, tmptable2, size*sizeof(u16))) {
		//	pr_info("Gamma table R update fail.\n");
		//	pr_info("Input gamma table[%d]:\n", size);
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		r, size*sizeof(u16), true);
		//	pr_info("Output gamma table:\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
		//else {
		//	pr_info("\nGamma table R update success.\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
	}
	if (g) {
		enable = 1;
		sp7350_crtc_tcon_gamma_table_set(crtc, SP7350_TCON_GM_UPDDEL_RGB_G, g, size);
		//sp7350_crtc_tcon_gamma_table_get(crtc, SP7350_TCON_GM_UPDDEL_RGB_G, tmptable2, size);
		//if (memcmp(g, tmptable2, size*sizeof(u16))) {
		//	pr_info("Gamma table G update fail.\n");
		//	pr_info("Input gamma table:\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		g, size*sizeof(u16), true);
		//	pr_info("Output gamma table:\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
		//else {
		//	pr_info("Gamma table G update success.\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
	}
	if (b) {
		enable = 1;
		sp7350_crtc_tcon_gamma_table_set(crtc, SP7350_TCON_GM_UPDDEL_RGB_B, b, size);
		//sp7350_crtc_tcon_gamma_table_get(crtc, SP7350_TCON_GM_UPDDEL_RGB_B, tmptable2, size);
		//if (memcmp(b, tmptable2, size*sizeof(u16))) {
		//	pr_info("Gamma table B update fail.\n");
		//	pr_info("Input gamma table:\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		b, size*sizeof(u16), true);
		//	pr_info("Output gamma table:\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
		//else {
		//	pr_info("Gamma table B update success.\n");
		//	print_hex_dump(KERN_INFO, "DISP DBG", DUMP_PREFIX_OFFSET, 16, 1,
		//		tmptable2, size*sizeof(u16), true);
		//}
	}
	sp7350_crtc_tcon_gamma_table_enable(crtc, enable);

	return 0;
}

static int sp7350_crtc_atomic_set_property(struct drm_crtc *crtc,
				   struct drm_crtc_state *state,
				   struct drm_property *property,
				   uint64_t val)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct sp7350_crtc_state *sp_state = to_sp7350_crtc_state(state);

	DRM_DEBUG_ATOMIC("Set crtc-%d property.name:%s val:%llu\n",
					 crtc->index, property->name, val);

	if (!strcmp(property->name, "BG_FORMAT")) {
		u32 bg_format_val = val;

		if (!(sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT)) {
			DRM_DEBUG_ATOMIC("the property isn't supported by the driver!\n");
			return -EINVAL;
		}

		DRM_DEBUG_ATOMIC("Set crtc-%d background color format: %4.4s\n",
						  crtc->index, drm_crtc_bg_format_enum_list[bg_format_val].name);

		sp_state->background_format = bg_format_val;
	} else if (!strcmp(property->name, "BG_COLOR")) {
		u32 bg_color_val = val;

		if (!(sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR)) {
			DRM_DEBUG_ATOMIC("the property isn't supported by the driver!\n");
			return -EINVAL;
		}

		DRM_DEBUG_ATOMIC("Set crtc-%d background color: 0x%06x\n",
						  crtc->index, bg_color_val);

		sp_state->background_color = bg_color_val;
	} else if (!strcmp(property->name, "GAMMA_LUT_ADJ")) {
		if (!(sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT)) {
			DRM_DEBUG_ATOMIC("the property isn't supported by the driver!\n");
			return -EINVAL;
		}

		sp_state->gamma_lut_adjustment_enable = val ? true : false;

	} else {
		DRM_DEBUG_ATOMIC("the property isn't implemented by the driver!\n");
		return -EINVAL;
	}

	return 0;
}

static int sp7350_crtc_atomic_get_property(struct drm_crtc *crtc,
				   const struct drm_crtc_state *state,
				   struct drm_property *property,
				   uint64_t *val)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct sp7350_crtc_state *sp_state = to_sp7350_crtc_state(state);

	DRM_DEBUG_ATOMIC("Get crtc-%d property.name:%s\n", crtc->index, property->name);

	if (property == sp_crtc->background_format_property) {
		if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT) {
			*val = sp_state->background_color;
			return 0;
		}
	} else if (property == sp_crtc->background_color_property) {
		if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR) {
			*val = sp_state->background_color;
			return 0;
		}
	} else if (property == sp_crtc->gamma_lut_adjustment_property) {
		if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT) {
			*val = sp_state->gamma_lut_adjustment_enable;
			return 0;
		}
	}

	DRM_DEBUG_ATOMIC("the property \"%s\" isn't implemented for crtc-%d!\n",
					 property->name, crtc->index);
	return -EINVAL;
}

static int sp7350_crtc_enable_vblank(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	DRM_DEBUG_DRIVER("[Start]\n");

	/* todo:no hw irq en reg??? */
	//if (!sp_crtc->irq_hw_enabled) {
	//	//enable_irq(sp_crtc->irq);
	//	devm_request_irq(&sp_crtc->pdev->dev, sp_crtc->irq, sp7350_crtc_irq_handler,
	//			IRQF_TRIGGER_RISING, "sp7350 crtc irq fs", sp_crtc);
	//}

	spin_lock(&sp_crtc->irq_lock);
	sp_crtc->irq_hw_enabled = true;
	spin_unlock(&sp_crtc->irq_lock);

	return 0;
}

static void sp7350_crtc_disable_vblank(struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	DRM_DEBUG_DRIVER("[Start]\n");

	/* todo:no hw irq en reg??? */
	//if (sp_crtc->irq_hw_enabled) {
	//	//disable_irq(sp_crtc->irq);
	//	devm_free_irq(&sp_crtc->pdev->dev, sp_crtc->irq, sp_crtc);
	//}

	spin_lock(&sp_crtc->irq_lock);
	sp_crtc->irq_hw_enabled = false;
	spin_unlock(&sp_crtc->irq_lock);
}

static void sp7350_crtc_atomic_print_state(struct drm_printer *p,
					 const struct drm_crtc_state *state)
{
	const struct drm_display_mode *mode = &state->adjusted_mode;

	drm_printf(p, "\tPixel clock = %uKHz\n", mode->clock);
}

static enum drm_mode_status sp7350_crtc_mode_valid(struct drm_crtc *crtc,
						const struct drm_display_mode *mode)
{
	DRM_DEBUG_DRIVER("[Start]\n");
	/* Any display HW(TGEN/DMIX/OSD/VPP...) Limit??? */
	if (mode->hdisplay > 1920)
		return MODE_BAD_HVALUE;

	if (mode->vdisplay > 1920)
		return MODE_BAD_VVALUE;

	if (mode->vdisplay >= mode->vtotal || mode->hdisplay >= mode->htotal)
		return MODE_BAD_VVALUE;

	return MODE_OK;
}

static bool sp7350_crtc_mode_fixup(struct drm_crtc *crtc,
			   const struct drm_display_mode *mode,
			   struct drm_display_mode *adjusted_mode)
{
	//struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	DRM_DEBUG_DRIVER("[Start]\n");

	/* fixup for hdmi ddc modes. */
	if (adjusted_mode->vsync_start - adjusted_mode->vdisplay == 1) {
		adjusted_mode->vsync_start += 1;
		adjusted_mode->vsync_end   += 1;
		DRM_DEBUG_DRIVER("\ncrtc adjusted mode(%s):\n"
			 "   hdisplay=%d, hsync_start=%d, hsync_end=%d, htotal=%d\n"
			 "   vdisplay=%d, vsync_start=%d, vsync_end=%d, vtotal=%d\n",
			 adjusted_mode->name,
			 adjusted_mode->hdisplay, adjusted_mode->hsync_start,
			 adjusted_mode->hsync_end, adjusted_mode->htotal,
			 adjusted_mode->vdisplay, adjusted_mode->vsync_start,
			 adjusted_mode->vsync_end, adjusted_mode->vtotal);
	}

	return true;
}

static int sp7350_crtc_atomic_check(struct drm_crtc *crtc,
					struct drm_atomic_state *state)
{
	int ret = 0;
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct drm_crtc_state *new_state = drm_atomic_get_new_crtc_state(state, crtc);
	struct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state, crtc);
	struct sp7350_crtc_state *sp_new_state = to_sp7350_crtc_state(new_state);
	struct sp7350_crtc_state *sp_old_state = to_sp7350_crtc_state(old_state);

	/* TODO reference to vkms_crtc_atomic_check */
	DRM_DEBUG_DRIVER("Start");

#if !SP7350_PLANE_ZPOS_AUTO_ADJUST_EN
	if (new_state->zpos_changed) {
		struct drm_plane *plane;
		int zpos_flag = 0;

		DRM_DEBUG_DRIVER("check zpos vaild\n");
		/* check zpos vaild */
		drm_for_each_plane(plane, crtc->dev) {
			struct drm_plane_state *new_plane_state = drm_atomic_get_plane_state(state, plane);

			if (plane->possible_crtcs != drm_crtc_mask(crtc))
				continue;

			DRM_DEBUG_DRIVER("plane-%d zpos:%d\n", plane->index, new_plane_state->zpos);
			if (zpos_flag & (1 << new_state->zpos)) {
				/* check fail, zpos conflict */
				DRM_DEBUG_DRIVER("check fail, zpos conflict.\n");
				ret = -EINVAL;
				break;
			}
			zpos_flag |= 1 << new_plane_state->zpos;
		}
	}
#endif

	if ((sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT) &&
		new_state->color_mgmt_changed && new_state->gamma_lut) {
		unsigned int len;

		len = drm_color_lut_size(new_state->gamma_lut);
		if (len != crtc->gamma_size) {
			DRM_DEBUG_DRIVER("Invalid LUT size; got %d, expected %d\n",
				      len, crtc->gamma_size);
			return -EINVAL;
		}
	}

	if ((sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT)
		&& (sp_new_state->background_format != sp_old_state->background_format)) {
		sp_new_state->background_changed = true;
	}
	if ((sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR)
		&& (sp_new_state->background_color != sp_old_state->background_color)) {
		sp_new_state->background_changed = true;
	}

	return ret;
}

static void sp7350_crtc_atomic_enable(struct drm_crtc *crtc,
					  struct drm_atomic_state *state)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	DRM_DEBUG_DRIVER("Enable\n");

	//ret = pm_runtime_resume_and_get(vop->dev);
	//if (ret < 0) {
	//	DRM_DEV_ERROR(vop->dev, "failed to get pm runtime: %d\n", ret);
	//	return ret;
	//}

	/* [TODO]clock & iommu enable. */

	mutex_lock(&sp_crtc->lock);
	sp_crtc->is_enabled = true;

	drm_crtc_vblank_on(crtc);
	mutex_unlock(&sp_crtc->lock);
}

static void sp7350_crtc_atomic_disable(struct drm_crtc *crtc,
					   struct drm_atomic_state *state)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);

	DRM_DEBUG_DRIVER("Disable\n");

	mutex_lock(&sp_crtc->lock);
	drm_crtc_vblank_off(crtc);

	sp_crtc->is_enabled = false;

	//pm_runtime_put(sp_crtc->dev);
	mutex_unlock(&sp_crtc->lock);
}

static void sp7350_crtc_atomic_begin(struct drm_crtc *crtc,
					 struct drm_atomic_state *state)
{
	/* TODO reference to vkms_crtc_atomic_begin */
	struct drm_crtc_state *new_state = drm_atomic_get_new_crtc_state(state, crtc);

	DRM_DEBUG_DRIVER("Start\n");
	if (new_state->mode_changed) {
		struct drm_display_mode *adj_mode = &crtc->state->adjusted_mode;

		if (adj_mode->hdisplay && adj_mode->vdisplay) {
			DRM_DEBUG_DRIVER("\nSET CRTC mode(%s):\n"
				 "   hdisplay=%d, hsync_start=%d, hsync_end=%d, htotal=%d\n"
				 "   vdisplay=%d, vsync_start=%d, vsync_end=%d, vtotal=%d\n",
				 adj_mode->name,
				 adj_mode->hdisplay, adj_mode->hsync_start, adj_mode->hsync_end, adj_mode->htotal,
				 adj_mode->vdisplay, adj_mode->vsync_start, adj_mode->vsync_end, adj_mode->vtotal);
			sp7350_crtc_tcon_timing_setting(crtc, adj_mode);
			#if SP7350_TCON_TPG_EN
			sp7350_crtc_tcon_tpg_setting(crtc, adj_mode);
			#endif
			sp7350_crtc_tgen_timing_setting(crtc, adj_mode);
		}
	}
	if (new_state->zpos_changed) {
		DRM_DEBUG_DRIVER("zpos_changed!!!\n");
		struct drm_plane *plane = NULL;
#if SP7350_PLANE_ZPOS_AUTO_ADJUST_EN
		unsigned int zpos[SP7350_MAX_PLANE];
		unsigned int zpos_adj[SP7350_MAX_PLANE];

		/* check zpos vaild */
		drm_for_each_plane(plane, crtc->dev) {
			struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);

			if (plane->possible_crtcs != drm_crtc_mask(crtc))
				continue;

			if (new_plane_state) {
				DRM_DEBUG_DRIVER("plane-%d zpos:%d\n", plane->index, new_plane_state->zpos);
				zpos[plane->index] = new_plane_state->zpos;
			}
		}

		DRM_DEBUG_DRIVER("rearrange zpos\n");
		sp7350_rearrange_zpos(zpos, zpos_adj, SP7350_MAX_PLANE);

		drm_for_each_plane(plane, crtc->dev) {
			struct sp7350_plane *sp_plane = to_sp7350_plane(plane);

			if (plane->possible_crtcs != drm_crtc_mask(crtc))
				continue;

			DRM_DEBUG_DRIVER("plane-%d, adj zpos:%d\n", plane->index, zpos_adj[plane->index]);
			switch (zpos_adj[plane->index]) {
			case 4:
				sp_plane->dmix_layer = SP7350_DMIX_L6;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L6;
				break;
			case 3:
				sp_plane->dmix_layer = SP7350_DMIX_L5;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L5;
				break;
			case 2:
				sp_plane->dmix_layer = SP7350_DMIX_L4;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L4;
				break;
			case 1:
				sp_plane->dmix_layer = SP7350_DMIX_L3;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L3;
				break;
			case 0:
				sp_plane->dmix_layer = SP7350_DMIX_L1;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L1;
				break;
			}
			sp_plane->zpos = zpos_adj[plane->index];
		}
#else
		drm_for_each_plane(plane, crtc->dev) {
			struct sp7350_plane *sp_plane = to_sp7350_plane(plane);
			struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);

			if (plane->possible_crtcs != drm_crtc_mask(crtc))
				continue;

			DRM_DEBUG_DRIVER("plane-%d zpos:%d\n", plane->index, new_plane_state->zpos);
			switch (new_plane_state->zpos) {
			case 4:
				sp_plane->dmix_layer = SP7350_DMIX_L6;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L6;
				break;
			case 3:
				sp_plane->dmix_layer = SP7350_DMIX_L5;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L5;
				break;
			case 2:
				sp_plane->dmix_layer = SP7350_DMIX_L4;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L4;
				break;
			case 1:
				sp_plane->dmix_layer = SP7350_DMIX_L3;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L3;
				break;
			case 0:
				sp_plane->dmix_layer = SP7350_DMIX_L1;
				sp_plane->dtg_adjust = SP7350_TGEN_DTG_ADJ_DMIX_L1;
				break;
			}
			sp_plane->zpos = new_plane_state->zpos;
		}
#endif
		sp7350_crtc_dmix_layer_setting(crtc);
	}
}

static void sp7350_crtc_atomic_flush(struct drm_crtc *crtc,
					 struct drm_atomic_state *state)
{
	/* TODO reference to vkms_crtc_atomic_flush */
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	struct drm_crtc_state *new_state = drm_atomic_get_new_crtc_state(state, crtc);
	struct sp7350_crtc_state *sp_state = to_sp7350_crtc_state(new_state);
	struct drm_pending_vblank_event *event = crtc->state->event;

	DRM_DEBUG_DRIVER("[Start]\n");
	//if (!sp_crtc->is_enabled)
	//	return;

	if ((sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT)
		&& (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR)
		&& sp_state->background_changed) {
		u32 value;

		DRM_DEBUG_DRIVER("background changed to %s 0x%06x\n",
			drm_crtc_bg_format_enum_list[sp_state->background_format].name,
			sp_state->background_color);

		/* DMIX PTG(BackGround Color Setting)
		 */
		value = 0;
		value |= (sp_state->background_color & 0xFFFFFF);
		SP7350_CRTC_WRITE(DMIX_PTG_CONFIG_2, value); //black for BackGround

		sp_state->background_changed = false;
		/* TODO: For YUV444 pixel format only!!! */
		sp_crtc->background_color = sp_state->background_color;
	}

	if ((sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT)
		 && new_state->color_mgmt_changed) {
		if (new_state->gamma_lut) {
			struct drm_color_lut *gamma_lut = new_state->gamma_lut->data;
			unsigned int gamma_lut_len = drm_color_lut_size(new_state->gamma_lut);
			uint16_t *r_base, *g_base, *b_base;
			int i;

			drm_WARN_ON(crtc->dev, gamma_lut_len != crtc->gamma_size);

			r_base = crtc->gamma_store;
			g_base = r_base + crtc->gamma_size;
			b_base = g_base + crtc->gamma_size;
			if (sp_state->gamma_lut_adjustment_enable)
				for (i = 0; i < gamma_lut_len; i++) {
					/* from [0-65535]([0, 0xFFFF]) quantify to [0-4095]([0, 0xFFF]) */
					r_base[i] = gamma_lut[i].red >> 4;
					g_base[i] = gamma_lut[i].green >> 4;
					b_base[i] = gamma_lut[i].blue >> 4;
				}
			else
				for (i = 0; i < gamma_lut_len; i++) {
					r_base[i] = gamma_lut[i].red;
					g_base[i] = gamma_lut[i].green;
					b_base[i] = gamma_lut[i].blue;
				}

			sp7350_crtc_gamma_set(crtc, r_base, g_base, b_base, gamma_lut_len, NULL);
			sp_crtc->gamma_lut_enabled = true;
		} else {
			sp7350_crtc_gamma_set(crtc, NULL, NULL, NULL, 0, NULL);
			sp_crtc->gamma_lut_enabled = false;
		}
	}

	/*
	 * [TODO]Wait irq???
	 */

	if (event) {
		crtc->state->event = NULL;

		spin_lock_irq(&crtc->dev->event_lock);
		if (drm_crtc_vblank_get(crtc) == 0)
			drm_crtc_arm_vblank_event(crtc, event);
		else
			drm_crtc_send_vblank_event(crtc, event);
		spin_unlock_irq(&crtc->dev->event_lock);
	}
}

static bool sp7350_crtc_get_scanout_position(struct drm_crtc *crtc,
					   bool in_vblank_irq,
					   int *vpos,
					   int *hpos,
					   ktime_t *stime,
					   ktime_t *etime,
					   const struct drm_display_mode *mode)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	int vsw, vbp, vactive_start, vactive_end, vfp_end;
	int x, y;
	u32 value;

	vsw = mode->crtc_vsync_end - mode->crtc_vsync_start;
	vbp = mode->crtc_vtotal - mode->crtc_vsync_end;
	//WARN_ON(!vsw);
	//WARN_ON(!vbp);

	vactive_start = vsw + vbp + 1;
	vactive_end = vactive_start + mode->crtc_vdisplay;

	/* last scan line before VSYNC */
	vfp_end = mode->crtc_vtotal;

	if (stime)
		*stime = ktime_get();

	/* [TODO]HOW do for DRM_MODE_FLAG_INTERLACE? */
	WARN_ON(mode->flags & DRM_MODE_FLAG_INTERLACE);

	value = SP7350_CRTC_READ(TGEN_DTG_STATUS1);
	y = value & 0xfff;  /* DTG_LINE_CNT[11:0] */
	value = SP7350_CRTC_READ(TGEN_DTG_STATUS2);
	x = value & 0x1fff;  /* DTG_PIX_CNT[12:0] */

	if (y > vactive_end)
		y = y - vfp_end - vactive_start;
	else
		y -= vactive_start;

	*vpos = y;
	//*hpos = 0; /* [TODO]WHY? */
	*hpos = x;

	if (etime)
		*etime = ktime_get();

	return true;
}

static const struct drm_crtc_funcs sp7350_crtc_funcs = {
	.destroy	= drm_crtc_cleanup,
	.set_config	= drm_atomic_helper_set_config,
	.page_flip	= drm_atomic_helper_page_flip,
	.reset		= sp7350_crtc_reset,
	//.gamma_set  = sp7350_crtc_gamma_set,
	.atomic_duplicate_state	= sp7350_crtc_atomic_duplicate_state,
	.atomic_destroy_state	= sp7350_crtc_atomic_destroy_state,
	.atomic_set_property = sp7350_crtc_atomic_set_property,
	.atomic_get_property = sp7350_crtc_atomic_get_property,
	.enable_vblank = sp7350_crtc_enable_vblank,
	.disable_vblank = sp7350_crtc_disable_vblank,
	.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,
	.atomic_print_state = sp7350_crtc_atomic_print_state,
};

static const struct drm_crtc_helper_funcs sp7350_crtc_helper_funcs = {
	.mode_valid	= sp7350_crtc_mode_valid,
	.mode_fixup     = sp7350_crtc_mode_fixup,
	.atomic_check	= sp7350_crtc_atomic_check,
	.atomic_begin	= sp7350_crtc_atomic_begin,
	.atomic_flush	= sp7350_crtc_atomic_flush,
	.atomic_enable	= sp7350_crtc_atomic_enable,
	.atomic_disable	= sp7350_crtc_atomic_disable,
	.get_scanout_position = sp7350_crtc_get_scanout_position,
};

static void sp7350_set_crtc_possible_masks(struct drm_device *drm,
					   struct drm_crtc *crtc)
{
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	const enum sp7350_encoder_type *encoder_types = sp_crtc->encoder_types;
	struct drm_encoder *encoder;

	drm_for_each_encoder(encoder, drm) {
		struct sp7350_encoder *sp_encoder;
		int i;

		if (encoder->encoder_type == DRM_MODE_ENCODER_VIRTUAL)
			continue;

		sp_encoder = to_sp7350_encoder(encoder);
		for (i = 0; i < SP7350_DRM_ENCODER_TYPE_MAX; i++) {
			if (sp_encoder->type == encoder_types[i]) {
				sp_encoder->clock_select = i;
				encoder->possible_crtcs |= drm_crtc_mask(crtc);
				break;
			}
		}
	}
}

int sp7350_crtc_init(struct drm_device *drm, struct drm_crtc *crtc,
		  const struct drm_crtc_funcs *crtc_funcs,
		  const struct drm_crtc_helper_funcs *crtc_helper_funcs)
{
	struct device_node *port;
	//struct sp7350_dev *sp_dev = to_sp7350_dev(drm);
	struct sp7350_crtc *sp_crtc = to_sp7350_crtc(crtc);
	//struct drm_crtc *crtc = &sp7350_crtc->base;
	int ret;

	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "of_get_child_by_name\n");
	port = of_get_child_by_name(sp_crtc->pdev->dev.of_node, "port");
	if (!port) {
		DRM_DEV_ERROR(drm->dev, "no port node found in %p\n", sp_crtc->pdev->dev.of_node);
		return -EINVAL;
	}
	of_node_put(port);
	crtc->port = port;

	/* NOTES: KEEP this as defalut setting!
	 * This may not be a good solution, but it is indeed an effective one.
	 * Becease:(VPP not support rgb pixel format)
	 * 1. legacy fbdev compatible /dev/fb0 with osd3.
	 * 2. work well with xorg-server for rgb format.
	 ****************
	 * VPP Layer map to overlay plane-1 for media plane usage.
	 * Maps list:
	 *----------------------------------------------------------------------------
	 * DRM-Layer | primary   | overlay-1  |  overlay-2  |  overlay-3  |   cursor
	 * planeId   | plane-0   |  plane-1   |   plane-2   |  plane-3    |  plane-4
	 * HW-Layer  |  OSD3     |   VPP0     |   OSD2      |   OSD1      |   OSD0
	 * DMIX-Layer|   L1      |    L3      |    L4       |    L5       |    L6
	 *  z-order  |    0      |     1      |     2       |     3       |     4
	 * usage     |  desktop  |   media    |   menu-1    |    menu-2   |    cursor
	 *----------------------------------------------------------------------------
	 * z-order is init_zpos.
	 */

	/* !!!Notes: DO NOT change the sp7350_plane_init order. */
	/* init plane for primary_plane */
	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "sp7350_plane_init (primary_plane)\n");
	sp_crtc->planes[0] =
		sp7350_plane_init(drm, DRM_PLANE_TYPE_PRIMARY, SP7350_PLANE_TYPE_OSD3, 0);
	if (IS_ERR(sp_crtc->planes[0]))
		return PTR_ERR(sp_crtc->planes[0]);

	/* init plane for media_plane */
	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "sp7350_plane_init (media_plane)\n");
	sp_crtc->planes[1] =
		sp7350_plane_init(drm, DRM_PLANE_TYPE_OVERLAY, SP7350_PLANE_TYPE_VPP0, 1);
	if (IS_ERR(sp_crtc->planes[1]))
		return PTR_ERR(sp_crtc->planes[1]);

	/* init plane for overlay_plane1 */
	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "sp7350_plane_init (overlay_plane1)\n");
	sp_crtc->planes[2] =
		sp7350_plane_init(drm, DRM_PLANE_TYPE_OVERLAY, SP7350_PLANE_TYPE_OSD2, 2);
	if (IS_ERR(sp_crtc->planes[2]))
		return PTR_ERR(sp_crtc->planes[2]);

	/* init plane for overlay_plane2 */
	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "sp7350_plane_init (overlay_plane2)\n");
	sp_crtc->planes[3] =
		sp7350_plane_init(drm, DRM_PLANE_TYPE_OVERLAY, SP7350_PLANE_TYPE_OSD1, 3);
	if (IS_ERR(sp_crtc->planes[3]))
		return PTR_ERR(sp_crtc->planes[3]);

	/* init plane for cursor_plane */
	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "sp7350_plane_init (cursor_plane)\n");
	sp_crtc->planes[4] =
		sp7350_plane_init(drm, DRM_PLANE_TYPE_CURSOR, SP7350_PLANE_TYPE_OSD0, 4);
	if (IS_ERR(sp_crtc->planes[4]))
		return PTR_ERR(sp_crtc->planes[4]);

	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "drm_crtc_init_with_planes\n");
	ret = drm_crtc_init_with_planes(drm, crtc, sp_crtc->planes[0],
				 sp_crtc->planes[SP7350_MAX_PLANE-1], crtc_funcs, NULL);
	if (ret) {
		DRM_DEV_ERROR(drm->dev, "failed to init crtc: %d\n", ret);
		return ret;
	}

	/* workaround for disable gamma table function. */
	//ret = drm_mode_crtc_set_gamma_size(crtc, 512);
	//if (ret) {
	//	DRM_DEV_ERROR(drm->dev, "failed to set gamma size: %d\n", ret);
	//	return ret;
	//}
	//drm_crtc_enable_color_mgmt(crtc, 0, false, 512);
	//sp_crtc->capabilities |=  SP7350_DRM_CRTC_CAP_GAMMA_LUT;
	//if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_GAMMA_LUT) {
	//	sp_crtc->gamma_lut_adjustment_property = drm_property_create_bool(crtc->dev,
	//					DRM_MODE_PROP_ATOMIC, "GAMMA_LUT_ADJ");
	//	drm_object_attach_property(&crtc->base,
	//		 sp_crtc->gamma_lut_adjustment_property, 1);
	//}

	DRM_DEV_DEBUG_DRIVER(&sp_crtc->pdev->dev, "drm_crtc_helper_add\n");
	drm_crtc_helper_add(crtc, crtc_helper_funcs);

	/* for overlay plane only. */
	//sp_crtc->planes[1]->possible_crtcs = GENMASK(drm->mode_config.num_crtc - 1, 0);
	//sp_crtc->planes[2]->possible_crtcs = GENMASK(drm->mode_config.num_crtc - 1, 0);
	//sp_crtc->planes[3]->possible_crtcs = GENMASK(drm->mode_config.num_crtc - 1, 0);

	/* black for BackGround */
	sp_crtc->background_color = SP7350_DMIX_PTG_BLACK;

	sp7350_crtc_dmix_init(crtc);
	sp7350_crtc_tgen_init(crtc);
	sp7350_crtc_tcon_init(crtc);

	sp_crtc->is_enabled = false;

	sp_crtc->capabilities |=  SP7350_DRM_CRTC_CAP_BG_FORMAT | SP7350_DRM_CRTC_CAP_BG_COLOR;
	if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_FORMAT) {
		sp_crtc->background_format_property = drm_property_create_enum(crtc->dev,
						DRM_MODE_PROP_IMMUTABLE, "BG_FORMAT",
						drm_crtc_bg_format_enum_list,
						ARRAY_SIZE(drm_crtc_bg_format_enum_list));
		drm_object_attach_property(&crtc->base,
			 sp_crtc->background_format_property, 1);
	}
	if (sp_crtc->capabilities & SP7350_DRM_CRTC_CAP_BG_COLOR) {
		/* background color format:YUV444 OR RGB888, region: 0x000000~0xffffff */
		sp_crtc->background_color_property = drm_property_create_range(crtc->dev,
					 DRM_MODE_PROP_RANGE, "BG_COLOR", 0, 0xffffffff);
		drm_object_attach_property(&crtc->base,
			 sp_crtc->background_color_property, SP7350_DMIX_PTG_BLACK);
	}

	return ret;
}

static int sp7350_crtc_bind(struct device *dev, struct device *master, void *data)
{
	struct drm_device *drm = dev_get_drvdata(master);
	struct sp7350_dev *sp_dev = to_sp7350_dev(drm);
	struct sp7350_crtc *sp_crtc = dev_get_drvdata(dev);
	struct drm_crtc *crtc = &sp_crtc->base;
	int ret;

	DRM_DEV_DEBUG_DRIVER(dev, "start\n");

	sp_crtc->drm_dev = drm;
	sp_dev->crtc_regs = sp_crtc->regs;

	DRM_DEV_DEBUG_DRIVER(dev, "sp7350_crtc_init\n");
	ret = sp7350_crtc_init(drm, crtc,
		&sp7350_crtc_funcs, &sp7350_crtc_helper_funcs);

	if (ret)
		return ret;

	DRM_DEV_DEBUG_DRIVER(dev, "sp7350_set_crtc_possible_masks\n");
	sp7350_set_crtc_possible_masks(drm, crtc);

	sp7350_debugfs_add_regset32(drm, "regs_g185", &sp_crtc->regset_g185);
	sp7350_debugfs_add_regset32(drm, "regs_g186", &sp_crtc->regset_g186);
	sp7350_debugfs_add_regset32(drm, "regs_g187", &sp_crtc->regset_g187);
	sp7350_debugfs_add_regset32(drm, "regs_g188", &sp_crtc->regset_g188);
	sp7350_debugfs_add_regset32(drm, "regs_g189", &sp_crtc->regset_g189);
	sp7350_debugfs_add_regset32(drm, "regs_g190", &sp_crtc->regset_g190);
	sp7350_debugfs_add_regset32(drm, "regs_g191", &sp_crtc->regset_g191);
	sp7350_debugfs_add_regset32(drm, "regs_g192", &sp_crtc->regset_g192);
	sp7350_debugfs_add_regset32(drm, "regs_g193", &sp_crtc->regset_g193);
	sp7350_debugfs_add_regset32(drm, "regs_g194", &sp_crtc->regset_g194);
	sp7350_debugfs_add_regset32(drm, "regs_g195", &sp_crtc->regset_g195);
	sp7350_debugfs_add_regset32(drm, "regs_g196", &sp_crtc->regset_g196);
	sp7350_debugfs_add_regset32(drm, "regs_g197", &sp_crtc->regset_g197);
	sp7350_debugfs_add_regset32(drm, "regs_g198", &sp_crtc->regset_g198);
	sp7350_debugfs_add_regset32(drm, "regs_g199", &sp_crtc->regset_g199);
	sp7350_debugfs_add_regset32(drm, "regs_g200", &sp_crtc->regset_g200);
	sp7350_debugfs_add_regset32(drm, "regs_g201", &sp_crtc->regset_g201);
	sp7350_debugfs_add_regset32(drm, "regs_g202", &sp_crtc->regset_g202);
	sp7350_debugfs_add_regset32(drm, "regs_g203", &sp_crtc->regset_g203);

	DRM_DEV_DEBUG_DRIVER(dev, "done\n");
	spin_lock(&sp_crtc->irq_lock);
	sp_crtc->irq_hw_enabled = true;
	spin_unlock(&sp_crtc->irq_lock);

	return 0;
}

static void sp7350_crtc_unbind(struct device *dev, struct device *master,
			       void *data)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct drm_device *drm = dev_get_drvdata(master);
	struct sp7350_crtc *sp_crtc = dev_get_drvdata(dev);

	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "drm_crtc_cleanup\n");
	drm_crtc_cleanup(&sp_crtc->base);
	sp_crtc->drm_dev = NULL;

	/* TODO Set S3V SOC DISPLAY REG, disable crtc things... */

	for (int i = 0; i < SP7350_MAX_PLANE; i++) {
		if (sp_crtc->planes[i]) {
			sp7350_plane_release(drm, sp_crtc->planes[i]);
			sp_crtc->planes[i] = NULL;
		}
	}
	spin_lock(&sp_crtc->irq_lock);
	sp_crtc->irq_hw_enabled = false;
	spin_unlock(&sp_crtc->irq_lock);
}

static const struct component_ops sp7350_crtc_ops = {
	.bind   = sp7350_crtc_bind,
	.unbind = sp7350_crtc_unbind,
};

static int sp7350_crtc_dev_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct sp7350_crtc *sp_crtc;
	struct drm_crtc *crtc;
	struct resource *res;
	int ret;

	DRM_DEV_DEBUG_DRIVER(dev, "start\n");

	sp_crtc = devm_kzalloc(dev, sizeof(*sp_crtc), GFP_KERNEL);
	if (!sp_crtc)
		return -ENOMEM;
	//dev_set_drvdata(dev, sp_crtc);

	crtc = &sp_crtc->base;

	sp_crtc->pdev = pdev;

	spin_lock_init(&sp_crtc->irq_lock);
	mutex_init(&sp_crtc->lock);

	/*
	 * get disp reg base (G185 - G203)
	 */
	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "devm_platform_get_and_ioremap_resource\n");
	sp_crtc->regs = devm_platform_get_and_ioremap_resource(sp_crtc->pdev, 0, &res);
	if (IS_ERR(sp_crtc->regs))
		return dev_err_probe(&pdev->dev, PTR_ERR(sp_crtc->regs), "reg base not found\n");

	/*
	 * VPP Layer debugfs init
	 */
	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "debugfs init for regset\n");
	sp_crtc->regset_g185.base = sp_crtc->regs + (SP7350_REG_OFFSET_IMGREAD_G185 << 7);
	sp_crtc->regset_g185.regs = crtc_regs_g185;
	sp_crtc->regset_g185.nregs = ARRAY_SIZE(crtc_regs_g185);

	sp_crtc->regset_g186.base = sp_crtc->regs + (SP7350_REG_OFFSET_VSCL_G186 << 7);
	sp_crtc->regset_g186.regs = crtc_regs_g186;
	sp_crtc->regset_g186.nregs = ARRAY_SIZE(crtc_regs_g186);

	sp_crtc->regset_g187.base = sp_crtc->regs + (SP7350_REG_OFFSET_VSCL_G187 << 7);
	sp_crtc->regset_g187.regs = crtc_regs_g187;
	sp_crtc->regset_g187.nregs = ARRAY_SIZE(crtc_regs_g187);

	sp_crtc->regset_g188.base = sp_crtc->regs + (SP7350_REG_OFFSET_VPOST_G188 << 7);
	sp_crtc->regset_g188.regs = crtc_regs_g188;
	sp_crtc->regset_g188.nregs = ARRAY_SIZE(crtc_regs_g188);

	/*
	 * OSD Layer debugfs init
	 */
	sp_crtc->regset_g189.base = sp_crtc->regs + (SP7350_REG_OFFSET_OSD0_G189 << 7);
	sp_crtc->regset_g189.regs = crtc_regs_g189;
	sp_crtc->regset_g189.nregs = ARRAY_SIZE(crtc_regs_g189);

	sp_crtc->regset_g190.base = sp_crtc->regs + (SP7350_REG_OFFSET_OSD1_G190 << 7);
	sp_crtc->regset_g190.regs = crtc_regs_g190;
	sp_crtc->regset_g190.nregs = ARRAY_SIZE(crtc_regs_g190);

	sp_crtc->regset_g191.base = sp_crtc->regs + (SP7350_REG_OFFSET_OSD2_G191 << 7);
	sp_crtc->regset_g191.regs = crtc_regs_g191;
	sp_crtc->regset_g191.nregs = ARRAY_SIZE(crtc_regs_g191);

	sp_crtc->regset_g192.base = sp_crtc->regs + (SP7350_REG_OFFSET_OSD3_G192 << 7);
	sp_crtc->regset_g192.regs = crtc_regs_g192;
	sp_crtc->regset_g192.nregs = ARRAY_SIZE(crtc_regs_g192);

	sp_crtc->regset_g193.base = sp_crtc->regs + (SP7350_REG_OFFSET_GPOST0_G193 << 7);
	sp_crtc->regset_g193.regs = crtc_regs_g193;
	sp_crtc->regset_g193.nregs = ARRAY_SIZE(crtc_regs_g193);

	sp_crtc->regset_g194.base = sp_crtc->regs + (SP7350_REG_OFFSET_GPOST1_G194 << 7);
	sp_crtc->regset_g194.regs = crtc_regs_g194;
	sp_crtc->regset_g194.nregs = ARRAY_SIZE(crtc_regs_g194);

	sp_crtc->regset_g195.base = sp_crtc->regs + (SP7350_REG_OFFSET_GPOST2_G195 << 7);
	sp_crtc->regset_g195.regs = crtc_regs_g195;
	sp_crtc->regset_g195.nregs = ARRAY_SIZE(crtc_regs_g195);

	sp_crtc->regset_g196.base = sp_crtc->regs + (SP7350_REG_OFFSET_GPOST3_G196 << 7);
	sp_crtc->regset_g196.regs = crtc_regs_g196;
	sp_crtc->regset_g196.nregs = ARRAY_SIZE(crtc_regs_g196);

	/*
	 * TGEN debugfs init
	 */
	sp_crtc->regset_g197.base = sp_crtc->regs + (SP7350_REG_OFFSET_TGEN_G197 << 7);
	sp_crtc->regset_g197.regs = crtc_regs_g197;
	sp_crtc->regset_g197.nregs = ARRAY_SIZE(crtc_regs_g197);
	/*
	 * DMIX debugfs init
	 */
	sp_crtc->regset_g198.base = sp_crtc->regs + (SP7350_REG_OFFSET_DMIX_G198 << 7);
	sp_crtc->regset_g198.regs = crtc_regs_g198;
	sp_crtc->regset_g198.nregs = ARRAY_SIZE(crtc_regs_g198);

	/*
	 * TCON debugfs init
	 */
	sp_crtc->regset_g199.base = sp_crtc->regs + (SP7350_REG_OFFSET_TCON_G199 << 7);
	sp_crtc->regset_g199.regs = crtc_regs_g199;
	sp_crtc->regset_g199.nregs = ARRAY_SIZE(crtc_regs_g199);

	sp_crtc->regset_g200.base = sp_crtc->regs + (SP7350_REG_OFFSET_TCON_G200 << 7);
	sp_crtc->regset_g200.regs = crtc_regs_g200;
	sp_crtc->regset_g200.nregs = ARRAY_SIZE(crtc_regs_g200);

	sp_crtc->regset_g201.base = sp_crtc->regs + (SP7350_REG_OFFSET_TCON_G201 << 7);
	sp_crtc->regset_g201.regs = crtc_regs_g201;
	sp_crtc->regset_g201.nregs = ARRAY_SIZE(crtc_regs_g201);

	sp_crtc->regset_g202.base = sp_crtc->regs + (SP7350_REG_OFFSET_TCON_G202_RESERVED << 7);
	sp_crtc->regset_g202.regs = crtc_regs_g202;
	sp_crtc->regset_g202.nregs = ARRAY_SIZE(crtc_regs_g202);

	sp_crtc->regset_g203.base = sp_crtc->regs + (SP7350_REG_OFFSET_TCON_G203 << 7);
	sp_crtc->regset_g203.regs = crtc_regs_g203;
	sp_crtc->regset_g203.nregs = ARRAY_SIZE(crtc_regs_g203);


	//pm_runtime_enable(&pdev->dev);

	//ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
	//		       sp7350_crtc_irq_handler,
	//		       IRQF_SHARED,
	//		       "sp7350 crtc", sp_crtc);
	sp_crtc->irq_hw_enabled = false;
	sp_crtc->irq = platform_get_irq(pdev, 0);
	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "devm_request_irq:%d\n", sp_crtc->irq);
	ret = devm_request_irq(&pdev->dev, sp_crtc->irq, sp7350_crtc_irq_handler,
			IRQF_TRIGGER_RISING, "sp7350 crtc irq fs", sp_crtc);
	if (ret)
		return dev_err_probe(&pdev->dev, ret, "devm_request_irq\n");

	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "platform_set_drvdata\n");
	platform_set_drvdata(pdev, sp_crtc);

	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "component_add\n");
	return component_add(&pdev->dev, &sp7350_crtc_ops);
}

static int sp7350_crtc_dev_remove(struct platform_device *pdev)
{
	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "component_del\n");

	component_del(&pdev->dev, &sp7350_crtc_ops);

	//DRM_DEV_DEBUG_DRIVER(&pdev->dev, "platform_set_drvdata\n");
	platform_set_drvdata(pdev, NULL);
	return 0;
}

static int sp7350_crtc_dev_suspend(struct platform_device *pdev, pm_message_t state)
{
	struct sp7350_crtc *sp_crtc = dev_get_drvdata(&pdev->dev);
	struct drm_plane *plane = NULL;

	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "[TODO]crtc driver suspend.\n");

	/* do nothing? */
	if (!sp_crtc->drm_dev || !sp_crtc->base.dev)
		return 0;

	drm_for_each_plane(plane, sp_crtc->drm_dev) {
		if (plane->possible_crtcs != drm_crtc_mask(&sp_crtc->base))
			continue;
		sp7350_plane_dev_suspend(&pdev->dev, plane);
	}

	return 0;
}

static int sp7350_crtc_dev_resume(struct platform_device *pdev)
{
	struct sp7350_crtc *sp_crtc = dev_get_drvdata(&pdev->dev);
	struct drm_plane *plane = NULL;

	DRM_DEV_DEBUG_DRIVER(&pdev->dev, "crtc driver resume.\n");

	if (sp_crtc) {
		sp7350_crtc_dmix_init(&sp_crtc->base);
		sp7350_crtc_tgen_init(&sp_crtc->base);
		sp7350_crtc_tcon_init(&sp_crtc->base);
		if (sp_crtc->is_enabled) {
			u32 value;

			sp7350_crtc_tgen_timing_setting(&sp_crtc->base, NULL);
			sp7350_crtc_tcon_timing_setting(&sp_crtc->base, NULL);
			#if SP7350_TCON_TPG_EN
			sp7350_crtc_tcon_tpg_setting(&sp_crtc->base, &sp_crtc->base.mode);
			#endif
			value = 0;
			value |= (sp_crtc->background_color & 0xFFFFFF);
			SP7350_CRTC_WRITE(DMIX_PTG_CONFIG_2, value);
			if (sp_crtc->gamma_lut_enabled) {
				uint16_t *r_base, *g_base, *b_base;

				r_base = sp_crtc->base.gamma_store;
				g_base = r_base + sp_crtc->base.gamma_size;
				b_base = g_base + sp_crtc->base.gamma_size;
				sp7350_crtc_gamma_set(&sp_crtc->base, r_base, g_base, b_base, sp_crtc->base.gamma_size, NULL);
			}
		}
		if (sp_crtc->drm_dev && sp_crtc->base.dev) {
			drm_for_each_plane(plane, sp_crtc->drm_dev) {
				if (plane->possible_crtcs != drm_crtc_mask(&sp_crtc->base))
					continue;
				sp7350_plane_dev_resume(&pdev->dev, plane);
			}
		}
	}

	return 0;
}

static const struct of_device_id sp7350_crtc_dt_match[] = {
	{ .compatible = "sunplus,sp7350-crtc0" },
	{}
};

struct platform_driver sp7350_crtc_driver = {
	.probe   = sp7350_crtc_dev_probe,
	.remove  = sp7350_crtc_dev_remove,
	.suspend = sp7350_crtc_dev_suspend,
	.resume  = sp7350_crtc_dev_resume,
	.driver  = {
		.name = "sp7350_crtc",
		.of_match_table = sp7350_crtc_dt_match,
	},
};
